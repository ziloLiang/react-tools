{"version":3,"sources":["node_modules/remarkable/lib/rules_block/blockquote.js"],"names":["module","exports","blockquote","state","startLine","endLine","silent","nextLine","lastLineEmpty","oldTShift","oldBMarks","oldIndent","oldParentType","lines","terminatorRules","i","l","terminate","pos","bMarks","tShift","max","eMarks","src","charCodeAt","level","options","maxNesting","blkIndent","skipSpaces","parser","ruler","getRules","push","length","parentType","tokens","type","tokenize","line"],"mappings":"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","file":"blockquote.js","sourceRoot":"/Users/liangdong06/work/react-tools","sourcesContent":["// Block quotes\n\n'use strict';\n\n\nmodule.exports = function blockquote(state, startLine, endLine, silent) {\n  var nextLine, lastLineEmpty, oldTShift, oldBMarks, oldIndent, oldParentType, lines,\n      terminatorRules,\n      i, l, terminate,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos > max) { return false; }\n\n  // check the block quote marker\n  if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }\n\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  // we know that it's going to be a valid blockquote,\n  // so no point trying to find the end of it in silent mode\n  if (silent) { return true; }\n\n  // skip one optional space after '>'\n  if (state.src.charCodeAt(pos) === 0x20) { pos++; }\n\n  oldIndent = state.blkIndent;\n  state.blkIndent = 0;\n\n  oldBMarks = [ state.bMarks[startLine] ];\n  state.bMarks[startLine] = pos;\n\n  // check if we have an empty blockquote\n  pos = pos < max ? state.skipSpaces(pos) : pos;\n  lastLineEmpty = pos >= max;\n\n  oldTShift = [ state.tShift[startLine] ];\n  state.tShift[startLine] = pos - state.bMarks[startLine];\n\n  terminatorRules = state.parser.ruler.getRules('blockquote');\n\n  // Search the end of the block\n  //\n  // Block ends with either:\n  //  1. an empty line outside:\n  //     ```\n  //     > test\n  //\n  //     ```\n  //  2. an empty line inside:\n  //     ```\n  //     >\n  //     test\n  //     ```\n  //  3. another tag\n  //     ```\n  //     > test\n  //      - - -\n  //     ```\n  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n    pos = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos >= max) {\n      // Case 1: line is not inside the blockquote, and this line is empty.\n      break;\n    }\n\n    if (state.src.charCodeAt(pos++) === 0x3E/* > */) {\n      // This line is inside the blockquote.\n\n      // skip one optional space after '>'\n      if (state.src.charCodeAt(pos) === 0x20) { pos++; }\n\n      oldBMarks.push(state.bMarks[nextLine]);\n      state.bMarks[nextLine] = pos;\n\n      pos = pos < max ? state.skipSpaces(pos) : pos;\n      lastLineEmpty = pos >= max;\n\n      oldTShift.push(state.tShift[nextLine]);\n      state.tShift[nextLine] = pos - state.bMarks[nextLine];\n      continue;\n    }\n\n    // Case 2: line is not inside the blockquote, and the last line was empty.\n    if (lastLineEmpty) { break; }\n\n    // Case 3: another tag found.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n\n    oldBMarks.push(state.bMarks[nextLine]);\n    oldTShift.push(state.tShift[nextLine]);\n\n    // A negative number means that this is a paragraph continuation;\n    //\n    // Any negative number will do the job here, but it's better for it\n    // to be large enough to make any bugs obvious.\n    state.tShift[nextLine] = -1337;\n  }\n\n  oldParentType = state.parentType;\n  state.parentType = 'blockquote';\n  state.tokens.push({\n    type: 'blockquote_open',\n    lines: lines = [ startLine, 0 ],\n    level: state.level++\n  });\n  state.parser.tokenize(state, startLine, nextLine);\n  state.tokens.push({\n    type: 'blockquote_close',\n    level: --state.level\n  });\n  state.parentType = oldParentType;\n  lines[1] = state.line;\n\n  // Restore original tShift; this might not be necessary since the parser\n  // has already been here, but just to make sure we can do that.\n  for (i = 0; i < oldTShift.length; i++) {\n    state.bMarks[i + startLine] = oldBMarks[i];\n    state.tShift[i + startLine] = oldTShift[i];\n  }\n  state.blkIndent = oldIndent;\n\n  return true;\n};\n"]}