{"version":3,"sources":["node_modules/remarkable/lib/rules_block/paragraph.js"],"names":["module","exports","paragraph","state","startLine","endLine","content","terminate","i","l","nextLine","terminatorRules","lineMax","isEmpty","parser","ruler","getRules","tShift","blkIndent","length","getLines","trim","line","tokens","push","type","tight","lines","level","children"],"mappings":"AAAA;;AAEA;;AAGAA,OAAOC,OAAP,GAAiB,SAASC,SAAT,CAAmBC,KAAnB,EAA0BC,SAA1B,CAAmC,aAAnC,EAAkD;AACjE,MAAIC,OAAJ;AAAA,MAAaC,OAAb;AAAA,MAAsBC,SAAtB;AAAA,MAAiCC,CAAjC;AAAA,MAAoCC,CAApC;AAAA,MACIC,WAAWN,YAAY,CAD3B;AAAA,MAEIO,eAFJ;;AAIAN,YAAUF,MAAMS,OAAhB;;AAEA;AACA,MAAIF,WAAWL,OAAX,IAAsB,CAACF,MAAMU,OAAN,CAAcH,QAAd,CAA3B,EAAoD;AAClDC,sBAAkBR,MAAMW,MAAN,CAAaC,KAAb,CAAmBC,QAAnB,CAA4B,WAA5B,CAAlB;;AAEA,WAAON,WAAWL,OAAX,IAAsB,CAACF,MAAMU,OAAN,CAAcH,QAAd,CAA9B,EAAuDA,UAAvD,EAAmE;AACjE;AACA;AACA,UAAIP,MAAMc,MAAN,CAAaP,QAAb,IAAyBP,MAAMe,SAA/B,GAA2C,CAA/C,EAAkD;AAAE;AAAW;;AAE/D;AACAX,kBAAY,KAAZ;AACA,WAAKC,IAAI,CAAJ,EAAOC,IAAIE,gBAAgBQ,MAAhC,EAAwCX,IAAIC,CAA5C,EAA+CD,GAA/C,EAAoD;AAClD,YAAIG,gBAAgBH,CAAhB,EAAmBL,KAAnB,EAA0BO,QAA1B,EAAoCL,OAApC,EAA6C,IAA7C,CAAJ,EAAwD;AACtDE,sBAAY,IAAZ;AACA;AACD;AACF;AACD,UAAIA,SAAJ,EAAe;AAAE;AAAQ;AAC1B;AACF;;AAEDD,YAAUH,MAAMiB,QAAN,CAAehB,SAAf,EAA0BM,QAA1B,EAAoCP,MAAMe,SAA1C,EAAqD,KAArD,EAA4DG,IAA5D,EAAV;;AAEAlB,QAAMmB,IAAN,GAAaZ,QAAb;AACA,MAAIJ,QAAQa,MAAZ,EAAoB;AAClBhB,UAAMoB,MAAN,CAAaC,IAAb,CAAkB;AAChBC,YAAM,gBADU;AAEhBC,aAAO,KAFS;AAGhBC,aAAO,CAAEvB,SAAF,EAAaD,MAAMmB,IAAnB,CAHS;AAIhBM,aAAOzB,MAAMyB;AAJG,KAAlB;AAMAzB,UAAMoB,MAAN,CAAaC,IAAb,CAAkB;AAChBC,YAAM,QADU;AAEhBnB,eAASA,OAFO;AAGhBsB,aAAOzB,MAAMyB,KAAN,GAAc,CAHL;AAIhBD,aAAO,CAAEvB,SAAF,EAAaD,MAAMmB,IAAnB,CAJS;AAKhBO,gBAAU;AALM,KAAlB;AAOA1B,UAAMoB,MAAN,CAAaC,IAAb,CAAkB;AAChBC,YAAM,iBADU;AAEhBC,aAAO,KAFS;AAGhBE,aAAOzB,MAAMyB;AAHG,KAAlB;AAKD;;AAED,SAAO,IAAP;AACD,CArDD","file":"paragraph.js","sourceRoot":"/Users/liangdong06/work/react-tools","sourcesContent":["// Paragraph\n\n'use strict';\n\n\nmodule.exports = function paragraph(state, startLine/*, endLine*/) {\n  var endLine, content, terminate, i, l,\n      nextLine = startLine + 1,\n      terminatorRules;\n\n  endLine = state.lineMax;\n\n  // jump line-by-line until empty one or EOF\n  if (nextLine < endLine && !state.isEmpty(nextLine)) {\n    terminatorRules = state.parser.ruler.getRules('paragraph');\n\n    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n      // this would be a code block normally, but after paragraph\n      // it's considered a lazy continuation regardless of what's there\n      if (state.tShift[nextLine] - state.blkIndent > 3) { continue; }\n\n      // Some tags can terminate paragraph without empty line.\n      terminate = false;\n      for (i = 0, l = terminatorRules.length; i < l; i++) {\n        if (terminatorRules[i](state, nextLine, endLine, true)) {\n          terminate = true;\n          break;\n        }\n      }\n      if (terminate) { break; }\n    }\n  }\n\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n\n  state.line = nextLine;\n  if (content.length) {\n    state.tokens.push({\n      type: 'paragraph_open',\n      tight: false,\n      lines: [ startLine, state.line ],\n      level: state.level\n    });\n    state.tokens.push({\n      type: 'inline',\n      content: content,\n      level: state.level + 1,\n      lines: [ startLine, state.line ],\n      children: []\n    });\n    state.tokens.push({\n      type: 'paragraph_close',\n      tight: false,\n      level: state.level\n    });\n  }\n\n  return true;\n};\n"]}