{"version":3,"sources":["node_modules/remarkable/lib/rules_inline/emphasis.js"],"names":["isAlphaNum","code","scanDelims","state","start","pos","lastChar","nextChar","count","can_open","can_close","max","posMax","marker","src","charCodeAt","delims","module","exports","emphasis","silent","startCount","found","oldCount","newCount","stack","res","pending","slice","level","options","maxNesting","pop","push","length","parser","skipToken","type","tokenize"],"mappings":"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","file":"emphasis.js","sourceRoot":"/Users/liangdong06/work/react-tools","sourcesContent":["// Process *this* and _that_\n\n'use strict';\n\n\nfunction isAlphaNum(code) {\n  return (code >= 0x30 /* 0 */ && code <= 0x39 /* 9 */) ||\n         (code >= 0x41 /* A */ && code <= 0x5A /* Z */) ||\n         (code >= 0x61 /* a */ && code <= 0x7A /* z */);\n}\n\n// parse sequence of emphasis markers,\n// \"start\" should point at a valid marker\nfunction scanDelims(state, start) {\n  var pos = start, lastChar, nextChar, count,\n      can_open = true,\n      can_close = true,\n      max = state.posMax,\n      marker = state.src.charCodeAt(start);\n\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n\n  while (pos < max && state.src.charCodeAt(pos) === marker) { pos++; }\n  if (pos >= max) { can_open = false; }\n  count = pos - start;\n\n  if (count >= 4) {\n    // sequence of four or more unescaped markers can't start/end an emphasis\n    can_open = can_close = false;\n  } else {\n    nextChar = pos < max ? state.src.charCodeAt(pos) : -1;\n\n    // check whitespace conditions\n    if (nextChar === 0x20 || nextChar === 0x0A) { can_open = false; }\n    if (lastChar === 0x20 || lastChar === 0x0A) { can_close = false; }\n\n    if (marker === 0x5F /* _ */) {\n      // check if we aren't inside the word\n      if (isAlphaNum(lastChar)) { can_open = false; }\n      if (isAlphaNum(nextChar)) { can_close = false; }\n    }\n  }\n\n  return {\n    can_open: can_open,\n    can_close: can_close,\n    delims: count\n  };\n}\n\nmodule.exports = function emphasis(state, silent) {\n  var startCount,\n      count,\n      found,\n      oldCount,\n      newCount,\n      stack,\n      res,\n      max = state.posMax,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (marker !== 0x5F/* _ */ && marker !== 0x2A /* * */) { return false; }\n  if (silent) { return false; } // don't run any pairs in validation mode\n\n  res = scanDelims(state, start);\n  startCount = res.delims;\n  if (!res.can_open) {\n    state.pos += startCount;\n    if (!silent) { state.pending += state.src.slice(start, state.pos); }\n    return true;\n  }\n\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  state.pos = start + startCount;\n  stack = [ startCount ];\n\n  while (state.pos < max) {\n    if (state.src.charCodeAt(state.pos) === marker) {\n      res = scanDelims(state, state.pos);\n      count = res.delims;\n      if (res.can_close) {\n        oldCount = stack.pop();\n        newCount = count;\n\n        while (oldCount !== newCount) {\n          if (newCount < oldCount) {\n            stack.push(oldCount - newCount);\n            break;\n          }\n\n          // assert(newCount > oldCount)\n          newCount -= oldCount;\n\n          if (stack.length === 0) { break; }\n          state.pos += oldCount;\n          oldCount = stack.pop();\n        }\n\n        if (stack.length === 0) {\n          startCount = oldCount;\n          found = true;\n          break;\n        }\n        state.pos += count;\n        continue;\n      }\n\n      if (res.can_open) { stack.push(count); }\n      state.pos += count;\n      continue;\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + startCount;\n\n  if (!silent) {\n    if (startCount === 2 || startCount === 3) {\n      state.push({ type: 'strong_open', level: state.level++ });\n    }\n    if (startCount === 1 || startCount === 3) {\n      state.push({ type: 'em_open', level: state.level++ });\n    }\n\n    state.parser.tokenize(state);\n\n    if (startCount === 1 || startCount === 3) {\n      state.push({ type: 'em_close', level: --state.level });\n    }\n    if (startCount === 2 || startCount === 3) {\n      state.push({ type: 'strong_close', level: --state.level });\n    }\n  }\n\n  state.pos = state.posMax + startCount;\n  state.posMax = max;\n  return true;\n};\n"]}