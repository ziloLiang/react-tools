{"version":3,"sources":["node_modules/remarkable/lib/rules_core/references.js"],"names":["StateInline","require","parseLinkLabel","parseLinkDestination","parseLinkTitle","normalizeReference","parseReference","str","parser","options","env","state","labelEnd","pos","max","code","start","href","title","label","charCodeAt","indexOf","posMax","src","linkContent","slice","references","module","exports","tokens","i","l","content","inlineMode","length","type","inline","trim","tight"],"mappings":"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","file":"references.js","sourceRoot":"/Users/liangdong06/work/react-tools","sourcesContent":["'use strict';\n\n\nvar StateInline          = require('../rules_inline/state_inline');\nvar parseLinkLabel       = require('../helpers/parse_link_label');\nvar parseLinkDestination = require('../helpers/parse_link_destination');\nvar parseLinkTitle       = require('../helpers/parse_link_title');\nvar normalizeReference   = require('../helpers/normalize_reference');\n\n\nfunction parseReference(str, parser, options, env) {\n  var state, labelEnd, pos, max, code, start, href, title, label;\n\n  if (str.charCodeAt(0) !== 0x5B/* [ */) { return -1; }\n\n  if (str.indexOf(']:') === -1) { return -1; }\n\n  state = new StateInline(str, parser, options, env, []);\n  labelEnd = parseLinkLabel(state, 0);\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return -1; }\n\n  max = state.posMax;\n\n  // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    code = state.src.charCodeAt(pos);\n    if (code !== 0x20 && code !== 0x0A) { break; }\n  }\n\n  // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n  if (!parseLinkDestination(state, pos)) { return -1; }\n  href = state.linkContent;\n  pos = state.pos;\n\n  // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n  start = pos;\n  for (pos = pos + 1; pos < max; pos++) {\n    code = state.src.charCodeAt(pos);\n    if (code !== 0x20 && code !== 0x0A) { break; }\n  }\n\n  // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n  if (pos < max && start !== pos && parseLinkTitle(state, pos)) {\n    title = state.linkContent;\n    pos = state.pos;\n  } else {\n    title = '';\n    pos = start;\n  }\n\n  // ensure that the end of the line is empty\n  while (pos < max && state.src.charCodeAt(pos) === 0x20/* space */) { pos++; }\n  if (pos < max && state.src.charCodeAt(pos) !== 0x0A) { return -1; }\n\n  label = normalizeReference(str.slice(1, labelEnd));\n  if (typeof env.references[label] === 'undefined') {\n    env.references[label] = { title: title, href: href };\n  }\n\n  return pos;\n}\n\n\nmodule.exports = function references(state) {\n  var tokens = state.tokens, i, l, content, pos;\n\n  state.env.references = state.env.references || {};\n\n  if (state.inlineMode) {\n    return;\n  }\n\n  // Scan definitions in paragraph inlines\n  for (i = 1, l = tokens.length - 1; i < l; i++) {\n    if (tokens[i].type === 'inline' &&\n        tokens[i - 1].type === 'paragraph_open' &&\n        tokens[i + 1].type === 'paragraph_close') {\n\n      content = tokens[i].content;\n      while (content.length) {\n        pos = parseReference(content, state.inline, state.options, state.env);\n        if (pos < 0) { break; }\n        content = content.slice(pos).trim();\n      }\n\n      tokens[i].content = content;\n      if (!content.length) {\n        tokens[i - 1].tight = true;\n        tokens[i + 1].tight = true;\n      }\n    }\n  }\n};\n"]}