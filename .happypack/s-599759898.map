{"version":3,"sources":["node_modules/remarkable/lib/rules_core/abbr.js"],"names":["StateInline","require","parseLinkLabel","parseAbbr","str","parserInline","options","env","state","labelEnd","pos","max","label","title","charCodeAt","indexOf","posMax","src","slice","trim","length","abbreviations","module","exports","abbr","tokens","i","l","content","inlineMode","type","inline","tight"],"mappings":"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","file":"abbr.js","sourceRoot":"/Users/liangdong06/work/react-tools","sourcesContent":["// Parse abbreviation definitions, i.e. `*[abbr]: description`\n//\n\n'use strict';\n\n\nvar StateInline    = require('../rules_inline/state_inline');\nvar parseLinkLabel = require('../helpers/parse_link_label');\n\n\nfunction parseAbbr(str, parserInline, options, env) {\n  var state, labelEnd, pos, max, label, title;\n\n  if (str.charCodeAt(0) !== 0x2A/* * */) { return -1; }\n  if (str.charCodeAt(1) !== 0x5B/* [ */) { return -1; }\n\n  if (str.indexOf(']:') === -1) { return -1; }\n\n  state = new StateInline(str, parserInline, options, env, []);\n  labelEnd = parseLinkLabel(state, 1);\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return -1; }\n\n  max = state.posMax;\n\n  // abbr title is always one line, so looking for ending \"\\n\" here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    if (state.src.charCodeAt(pos) === 0x0A) { break; }\n  }\n\n  label = str.slice(2, labelEnd);\n  title = str.slice(labelEnd + 2, pos).trim();\n  if (title.length === 0) { return -1; }\n  if (!env.abbreviations) { env.abbreviations = {}; }\n  // prepend ':' to avoid conflict with Object.prototype members\n  if (typeof env.abbreviations[':' + label] === 'undefined') {\n    env.abbreviations[':' + label] = title;\n  }\n\n  return pos;\n}\n\nmodule.exports = function abbr(state) {\n  var tokens = state.tokens, i, l, content, pos;\n\n  if (state.inlineMode) {\n    return;\n  }\n\n  // Parse inlines\n  for (i = 1, l = tokens.length - 1; i < l; i++) {\n    if (tokens[i - 1].type === 'paragraph_open' &&\n        tokens[i].type === 'inline' &&\n        tokens[i + 1].type === 'paragraph_close') {\n\n      content = tokens[i].content;\n      while (content.length) {\n        pos = parseAbbr(content, state.inline, state.options, state.env);\n        if (pos < 0) { break; }\n        content = content.slice(pos).trim();\n      }\n\n      tokens[i].content = content;\n      if (!content.length) {\n        tokens[i - 1].tight = true;\n        tokens[i + 1].tight = true;\n      }\n    }\n  }\n};\n"]}