{"version":3,"sources":["node_modules/remarkable/lib/rules_core/linkify.js"],"names":["Autolinker","require","LINK_SCAN_RE","isLinkOpen","str","test","isLinkClose","createLinkifier","links","autolinker","stripPrefix","url","email","twitter","replaceFn","linker","match","getType","push","text","matchedText","getUrl","getEmail","replace","module","exports","linkify","state","i","j","l","tokens","token","nodes","ln","pos","level","htmlLinkLevel","blockTokens","linkifier","options","length","type","children","content","link","inline","validateLink","indexOf","slice","href","title","concat"],"mappings":"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","file":"linkify.js","sourceRoot":"/Users/liangdong06/work/react-tools","sourcesContent":["// Replace link-like texts with link nodes.\n//\n// Currently restricted by `inline.validateLink()` to http/https/ftp\n//\n'use strict';\n\n\nvar Autolinker = require('autolinker');\n\n\nvar LINK_SCAN_RE = /www|@|\\:\\/\\//;\n\n\nfunction isLinkOpen(str) {\n  return /^<a[>\\s]/i.test(str);\n}\nfunction isLinkClose(str) {\n  return /^<\\/a\\s*>/i.test(str);\n}\n\n// Stupid fabric to avoid singletons, for thread safety.\n// Required for engines like Nashorn.\n//\nfunction createLinkifier() {\n  var links = [];\n  var autolinker = new Autolinker({\n    stripPrefix: false,\n    url: true,\n    email: true,\n    twitter: false,\n    replaceFn: function (linker, match) {\n      // Only collect matched strings but don't change anything.\n      switch (match.getType()) {\n        /*eslint default-case:0*/\n        case 'url':\n          links.push({\n            text: match.matchedText,\n            url: match.getUrl()\n          });\n          break;\n        case 'email':\n          links.push({\n            text: match.matchedText,\n            // normalize email protocol\n            url: 'mailto:' + match.getEmail().replace(/^mailto:/i, '')\n          });\n          break;\n      }\n      return false;\n    }\n  });\n\n  return {\n    links: links,\n    autolinker: autolinker\n  };\n}\n\n\nmodule.exports = function linkify(state) {\n  var i, j, l, tokens, token, text, nodes, ln, pos, level, htmlLinkLevel,\n      blockTokens = state.tokens,\n      linkifier = null, links, autolinker;\n\n  if (!state.options.linkify) { return; }\n\n  for (j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline') { continue; }\n    tokens = blockTokens[j].children;\n\n    htmlLinkLevel = 0;\n\n    // We scan from the end, to keep position when new tags added.\n    // Use reversed logic in links start/end match\n    for (i = tokens.length - 1; i >= 0; i--) {\n      token = tokens[i];\n\n      // Skip content of markdown links\n      if (token.type === 'link_close') {\n        i--;\n        while (tokens[i].level !== token.level && tokens[i].type !== 'link_open') {\n          i--;\n        }\n        continue;\n      }\n\n      // Skip content of html tag links\n      if (token.type === 'htmltag') {\n        if (isLinkOpen(token.content) && htmlLinkLevel > 0) {\n          htmlLinkLevel--;\n        }\n        if (isLinkClose(token.content)) {\n          htmlLinkLevel++;\n        }\n      }\n      if (htmlLinkLevel > 0) { continue; }\n\n      if (token.type === 'text' && LINK_SCAN_RE.test(token.content)) {\n\n        // Init linkifier in lazy manner, only if required.\n        if (!linkifier) {\n          linkifier = createLinkifier();\n          links = linkifier.links;\n          autolinker = linkifier.autolinker;\n        }\n\n        text = token.content;\n        links.length = 0;\n        autolinker.link(text);\n\n        if (!links.length) { continue; }\n\n        // Now split string to nodes\n        nodes = [];\n        level = token.level;\n\n        for (ln = 0; ln < links.length; ln++) {\n\n          if (!state.inline.validateLink(links[ln].url)) { continue; }\n\n          pos = text.indexOf(links[ln].text);\n\n          if (pos) {\n            level = level;\n            nodes.push({\n              type: 'text',\n              content: text.slice(0, pos),\n              level: level\n            });\n          }\n          nodes.push({\n            type: 'link_open',\n            href: links[ln].url,\n            title: '',\n            level: level++\n          });\n          nodes.push({\n            type: 'text',\n            content: links[ln].text,\n            level: level\n          });\n          nodes.push({\n            type: 'link_close',\n            level: --level\n          });\n          text = text.slice(pos + links[ln].text.length);\n        }\n        if (text.length) {\n          nodes.push({\n            type: 'text',\n            content: text,\n            level: level\n          });\n        }\n\n        // replace current node\n        blockTokens[j].children = tokens = [].concat(tokens.slice(0, i), nodes, tokens.slice(i + 1));\n      }\n    }\n  }\n};\n"]}