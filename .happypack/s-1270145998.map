{"version":3,"sources":["node_modules/remarkable/lib/parser_block.js"],"names":["Ruler","require","StateBlock","_rules","ParserBlock","ruler","i","length","push","alt","slice","prototype","tokenize","state","startLine","endLine","rules","getRules","len","line","hasEmptyLines","ok","skipEmptyLines","tShift","blkIndent","tight","isEmpty","parentType","TABS_SCAN_RE","NEWLINES_RE","SPACES_RE","parse","str","options","env","outTokens","lineStart","lastTabPos","replace","indexOf","match","offset","result","charCodeAt","lineMax","module","exports"],"mappings":"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","file":"parser_block.js","sourceRoot":"/Users/liangdong06/work/react-tools","sourcesContent":["'use strict';\n\n/**\n * Local dependencies\n */\n\nvar Ruler      = require('./ruler');\nvar StateBlock = require('./rules_block/state_block');\n\n/**\n * Parser rules\n */\n\nvar _rules = [\n  [ 'code',       require('./rules_block/code') ],\n  [ 'fences',     require('./rules_block/fences'),     [ 'paragraph', 'blockquote', 'list' ] ],\n  [ 'blockquote', require('./rules_block/blockquote'), [ 'paragraph', 'blockquote', 'list' ] ],\n  [ 'hr',         require('./rules_block/hr'),         [ 'paragraph', 'blockquote', 'list' ] ],\n  [ 'list',       require('./rules_block/list'),       [ 'paragraph', 'blockquote' ] ],\n  [ 'footnote',   require('./rules_block/footnote'),   [ 'paragraph' ] ],\n  [ 'heading',    require('./rules_block/heading'),    [ 'paragraph', 'blockquote' ] ],\n  [ 'lheading',   require('./rules_block/lheading') ],\n  [ 'htmlblock',  require('./rules_block/htmlblock'),  [ 'paragraph', 'blockquote' ] ],\n  [ 'table',      require('./rules_block/table'),      [ 'paragraph' ] ],\n  [ 'deflist',    require('./rules_block/deflist'),    [ 'paragraph' ] ],\n  [ 'paragraph',  require('./rules_block/paragraph') ]\n];\n\n/**\n * Block Parser class\n *\n * @api private\n */\n\nfunction ParserBlock() {\n  this.ruler = new Ruler();\n  for (var i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1], {\n      alt: (_rules[i][2] || []).slice()\n    });\n  }\n}\n\n/**\n * Generate tokens for the given input range.\n *\n * @param  {Object} `state` Has properties like `src`, `parser`, `options` etc\n * @param  {Number} `startLine`\n * @param  {Number} `endLine`\n * @api private\n */\n\nParserBlock.prototype.tokenize = function (state, startLine, endLine) {\n  var rules = this.ruler.getRules('');\n  var len = rules.length;\n  var line = startLine;\n  var hasEmptyLines = false;\n  var ok, i;\n\n  while (line < endLine) {\n    state.line = line = state.skipEmptyLines(line);\n    if (line >= endLine) {\n      break;\n    }\n\n    // Termination condition for nested calls.\n    // Nested calls currently used for blockquotes & lists\n    if (state.tShift[line] < state.blkIndent) {\n      break;\n    }\n\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.line`\n    // - update `state.tokens`\n    // - return true\n\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, line, endLine, false);\n      if (ok) {\n        break;\n      }\n    }\n\n    // set state.tight iff we had an empty line before current tag\n    // i.e. latest empty line should not count\n    state.tight = !hasEmptyLines;\n\n    // paragraph might \"eat\" one newline after it in nested lists\n    if (state.isEmpty(state.line - 1)) {\n      hasEmptyLines = true;\n    }\n\n    line = state.line;\n\n    if (line < endLine && state.isEmpty(line)) {\n      hasEmptyLines = true;\n      line++;\n\n      // two empty lines should stop the parser in list mode\n      if (line < endLine && state.parentType === 'list' && state.isEmpty(line)) { break; }\n      state.line = line;\n    }\n  }\n};\n\nvar TABS_SCAN_RE = /[\\n\\t]/g;\nvar NEWLINES_RE  = /\\r[\\n\\u0085]|[\\u2424\\u2028\\u0085]/g;\nvar SPACES_RE    = /\\u00a0/g;\n\n/**\n * Tokenize the given `str`.\n *\n * @param  {String} `str` Source string\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @param  {Array} `outTokens`\n * @api private\n */\n\nParserBlock.prototype.parse = function (str, options, env, outTokens) {\n  var state, lineStart = 0, lastTabPos = 0;\n  if (!str) { return []; }\n\n  // Normalize spaces\n  str = str.replace(SPACES_RE, ' ');\n\n  // Normalize newlines\n  str = str.replace(NEWLINES_RE, '\\n');\n\n  // Replace tabs with proper number of spaces (1..4)\n  if (str.indexOf('\\t') >= 0) {\n    str = str.replace(TABS_SCAN_RE, function (match, offset) {\n      var result;\n      if (str.charCodeAt(offset) === 0x0A) {\n        lineStart = offset + 1;\n        lastTabPos = 0;\n        return match;\n      }\n      result = '    '.slice((offset - lineStart - lastTabPos) % 4);\n      lastTabPos = offset - lineStart + 1;\n      return result;\n    });\n  }\n\n  state = new StateBlock(str, this, options, env, outTokens);\n  this.tokenize(state, state.line, state.lineMax);\n};\n\n/**\n * Expose `ParserBlock`\n */\n\nmodule.exports = ParserBlock;\n"]}