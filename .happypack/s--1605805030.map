{"version":3,"sources":["node_modules/remarkable/lib/rules_block/deflist.js"],"names":["skipMarker","state","line","pos","marker","start","bMarks","tShift","max","eMarks","src","charCodeAt","skipSpaces","markTightParagraphs","idx","i","l","level","tokens","length","type","tight","module","exports","deflist","startLine","endLine","silent","contentStart","ddLine","dtLine","itemLines","listLines","listTokIdx","nextLine","oldIndent","oldDDIndent","oldParentType","oldTShift","oldTight","prevEmptyEnd","ddIndent","isEmpty","blkIndent","options","maxNesting","push","lines","OUTER","content","getLines","trim","children","parentType","parser","tokenize"],"mappings":"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","file":"deflist.js","sourceRoot":"/Users/liangdong06/work/react-tools","sourcesContent":["// Definition lists\n\n'use strict';\n\n\n// Search `[:~][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipMarker(state, line) {\n  var pos, marker,\n      start = state.bMarks[line] + state.tShift[line],\n      max = state.eMarks[line];\n\n  if (start >= max) { return -1; }\n\n  // Check bullet\n  marker = state.src.charCodeAt(start++);\n  if (marker !== 0x7E/* ~ */ && marker !== 0x3A/* : */) { return -1; }\n\n  pos = state.skipSpaces(start);\n\n  // require space after \":\"\n  if (start === pos) { return -1; }\n\n  // no empty definitions, e.g. \"  : \"\n  if (pos >= max) { return -1; }\n\n  return pos;\n}\n\nfunction markTightParagraphs(state, idx) {\n  var i, l,\n      level = state.level + 2;\n\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].tight = true;\n      state.tokens[i].tight = true;\n      i += 2;\n    }\n  }\n}\n\nmodule.exports = function deflist(state, startLine, endLine, silent) {\n  var contentStart,\n      ddLine,\n      dtLine,\n      itemLines,\n      listLines,\n      listTokIdx,\n      nextLine,\n      oldIndent,\n      oldDDIndent,\n      oldParentType,\n      oldTShift,\n      oldTight,\n      prevEmptyEnd,\n      tight;\n\n  if (silent) {\n    // quirk: validation mode validates a dd block only, not a whole deflist\n    if (state.ddIndent < 0) { return false; }\n    return skipMarker(state, startLine) >= 0;\n  }\n\n  nextLine = startLine + 1;\n  if (state.isEmpty(nextLine)) {\n    if (++nextLine > endLine) { return false; }\n  }\n\n  if (state.tShift[nextLine] < state.blkIndent) { return false; }\n  contentStart = skipMarker(state, nextLine);\n  if (contentStart < 0) { return false; }\n\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  // Start list\n  listTokIdx = state.tokens.length;\n\n  state.tokens.push({\n    type: 'dl_open',\n    lines: listLines = [ startLine, 0 ],\n    level: state.level++\n  });\n\n  //\n  // Iterate list items\n  //\n\n  dtLine = startLine;\n  ddLine = nextLine;\n\n  // One definition list can contain multiple DTs,\n  // and one DT can be followed by multiple DDs.\n  //\n  // Thus, there is two loops here, and label is\n  // needed to break out of the second one\n  //\n  /*eslint no-labels:0,block-scoped-var:0*/\n  OUTER:\n  for (;;) {\n    tight = true;\n    prevEmptyEnd = false;\n\n    state.tokens.push({\n      type: 'dt_open',\n      lines: [ dtLine, dtLine ],\n      level: state.level++\n    });\n    state.tokens.push({\n      type: 'inline',\n      content: state.getLines(dtLine, dtLine + 1, state.blkIndent, false).trim(),\n      level: state.level + 1,\n      lines: [ dtLine, dtLine ],\n      children: []\n    });\n    state.tokens.push({\n      type: 'dt_close',\n      level: --state.level\n    });\n\n    for (;;) {\n      state.tokens.push({\n        type: 'dd_open',\n        lines: itemLines = [ nextLine, 0 ],\n        level: state.level++\n      });\n\n      oldTight = state.tight;\n      oldDDIndent = state.ddIndent;\n      oldIndent = state.blkIndent;\n      oldTShift = state.tShift[ddLine];\n      oldParentType = state.parentType;\n      state.blkIndent = state.ddIndent = state.tShift[ddLine] + 2;\n      state.tShift[ddLine] = contentStart - state.bMarks[ddLine];\n      state.tight = true;\n      state.parentType = 'deflist';\n\n      state.parser.tokenize(state, ddLine, endLine, true);\n\n      // If any of list item is tight, mark list as tight\n      if (!state.tight || prevEmptyEnd) {\n        tight = false;\n      }\n      // Item become loose if finish with empty line,\n      // but we should filter last element, because it means list finish\n      prevEmptyEnd = (state.line - ddLine) > 1 && state.isEmpty(state.line - 1);\n\n      state.tShift[ddLine] = oldTShift;\n      state.tight = oldTight;\n      state.parentType = oldParentType;\n      state.blkIndent = oldIndent;\n      state.ddIndent = oldDDIndent;\n\n      state.tokens.push({\n        type: 'dd_close',\n        level: --state.level\n      });\n\n      itemLines[1] = nextLine = state.line;\n\n      if (nextLine >= endLine) { break OUTER; }\n\n      if (state.tShift[nextLine] < state.blkIndent) { break OUTER; }\n      contentStart = skipMarker(state, nextLine);\n      if (contentStart < 0) { break; }\n\n      ddLine = nextLine;\n\n      // go to the next loop iteration:\n      // insert DD tag and repeat checking\n    }\n\n    if (nextLine >= endLine) { break; }\n    dtLine = nextLine;\n\n    if (state.isEmpty(dtLine)) { break; }\n    if (state.tShift[dtLine] < state.blkIndent) { break; }\n\n    ddLine = dtLine + 1;\n    if (ddLine >= endLine) { break; }\n    if (state.isEmpty(ddLine)) { ddLine++; }\n    if (ddLine >= endLine) { break; }\n\n    if (state.tShift[ddLine] < state.blkIndent) { break; }\n    contentStart = skipMarker(state, ddLine);\n    if (contentStart < 0) { break; }\n\n    // go to the next loop iteration:\n    // insert DT and DD tags and repeat checking\n  }\n\n  // Finilize list\n  state.tokens.push({\n    type: 'dl_close',\n    level: --state.level\n  });\n  listLines[1] = nextLine;\n\n  state.line = nextLine;\n\n  // mark paragraphs tight if needed\n  if (tight) {\n    markTightParagraphs(state, listTokIdx);\n  }\n\n  return true;\n};\n"]}